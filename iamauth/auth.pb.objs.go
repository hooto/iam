// Code generated by github.com/hooto/protobuf_slice
// source: auth.proto
// DO NOT EDIT!

package iamauth

import "sync"

var object_slice_mu_AuthKey sync.RWMutex

func (it *AuthKey) Equal(it2 *AuthKey) bool {
	if it2 == nil ||
		it.AccessKey != it2.AccessKey ||
		it.SecretKey != it2.SecretKey ||
		it.User != it2.User {
		return false
	}
	return true
}

func (it *AuthKey) Sync(it2 *AuthKey) bool {
	if it2 == nil {
		return false
	}
	if it.Equal(it2) {
		return false
	}
	*it = *it2
	return true
}

func AuthKeySliceGet(ls []*AuthKey, arg_accesskey string) *AuthKey {
	object_slice_mu_AuthKey.RLock()
	defer object_slice_mu_AuthKey.RUnlock()

	for _, v := range ls {
		if v.AccessKey == arg_accesskey {
			return v
		}
	}
	return nil
}

func AuthKeySliceDel(ls []*AuthKey, arg_accesskey string) ([]*AuthKey, bool) {
	object_slice_mu_AuthKey.Lock()
	defer object_slice_mu_AuthKey.Unlock()
	for i, v := range ls {
		if v.AccessKey == arg_accesskey {
			ls = append(ls[:i], ls[i+1:]...)
			return ls, true
		}
	}
	return ls, false
}

func AuthKeySliceEqual(ls, ls2 []*AuthKey) bool {
	object_slice_mu_AuthKey.RLock()
	defer object_slice_mu_AuthKey.RUnlock()

	if len(ls) != len(ls2) {
		return false
	}
	hit := false
	for _, v := range ls {
		hit = false
		for _, v2 := range ls2 {
			if v.AccessKey != v2.AccessKey {
				continue
			}
			if !v.Equal(v2) {
				return false
			}
			hit = true
			break
		}
		if !hit {
			return false
		}
	}
	return true
}

func AuthKeySliceSync(ls []*AuthKey, it2 *AuthKey) ([]*AuthKey, bool) {
	if it2 == nil {
		return ls, false
	}
	object_slice_mu_AuthKey.Lock()
	defer object_slice_mu_AuthKey.Unlock()

	hit := false
	changed := false
	for i, v := range ls {
		if v.AccessKey != it2.AccessKey {
			continue
		}
		if !v.Equal(it2) {
			ls[i], changed = it2, true
		}
		hit = true
		break
	}
	if !hit {
		ls = append(ls, it2)
		changed = true
	}
	return ls, changed
}

func AuthKeySliceSyncSlice(ls, ls2 []*AuthKey) ([]*AuthKey, bool) {
	if AuthKeySliceEqual(ls, ls2) {
		return ls, false
	}
	return ls2, true
}

var object_slice_mu_UserPayload sync.RWMutex

func (it *UserPayload) Equal(it2 *UserPayload) bool {
	if it2 == nil ||
		it.Id != it2.Id ||
		it.Name != it2.Name ||
		!PbUint32SliceEqual(it.Roles, it2.Roles) ||
		!PbStringSliceEqual(it.Groups, it2.Groups) ||
		it.Expired != it2.Expired {
		return false
	}
	return true
}

func (it *UserPayload) Sync(it2 *UserPayload) bool {
	if it2 == nil {
		return false
	}
	if it.Equal(it2) {
		return false
	}
	*it = *it2
	return true
}

func UserPayloadSliceGet(ls []*UserPayload, arg_id string) *UserPayload {
	object_slice_mu_UserPayload.RLock()
	defer object_slice_mu_UserPayload.RUnlock()

	for _, v := range ls {
		if v.Id == arg_id {
			return v
		}
	}
	return nil
}

func UserPayloadSliceDel(ls []*UserPayload, arg_id string) ([]*UserPayload, bool) {
	object_slice_mu_UserPayload.Lock()
	defer object_slice_mu_UserPayload.Unlock()
	for i, v := range ls {
		if v.Id == arg_id {
			ls = append(ls[:i], ls[i+1:]...)
			return ls, true
		}
	}
	return ls, false
}

func UserPayloadSliceEqual(ls, ls2 []*UserPayload) bool {
	object_slice_mu_UserPayload.RLock()
	defer object_slice_mu_UserPayload.RUnlock()

	if len(ls) != len(ls2) {
		return false
	}
	hit := false
	for _, v := range ls {
		hit = false
		for _, v2 := range ls2 {
			if v.Id != v2.Id {
				continue
			}
			if !v.Equal(v2) {
				return false
			}
			hit = true
			break
		}
		if !hit {
			return false
		}
	}
	return true
}

func UserPayloadSliceSync(ls []*UserPayload, it2 *UserPayload) ([]*UserPayload, bool) {
	if it2 == nil {
		return ls, false
	}
	object_slice_mu_UserPayload.Lock()
	defer object_slice_mu_UserPayload.Unlock()

	hit := false
	changed := false
	for i, v := range ls {
		if v.Id != it2.Id {
			continue
		}
		if !v.Equal(it2) {
			ls[i], changed = it2, true
		}
		hit = true
		break
	}
	if !hit {
		ls = append(ls, it2)
		changed = true
	}
	return ls, changed
}

func UserPayloadSliceSyncSlice(ls, ls2 []*UserPayload) ([]*UserPayload, bool) {
	if UserPayloadSliceEqual(ls, ls2) {
		return ls, false
	}
	return ls2, true
}
